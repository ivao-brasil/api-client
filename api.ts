/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * IVAO Brasil
 * API p√∫blica da IVAO Brasil
 *
 * OpenAPI spec version: 1.0.0
 * Contact: br-web@ivao.aero
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://api.br.ivao.aero/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ATCRating {
    NONE = <any> 'NONE',
    NOTATC = <any> 'NOT_ATC',
    AS1 = <any> 'AS1',
    AS2 = <any> 'AS2',
    AS3 = <any> 'AS3',
    ADC = <any> 'ADC',
    APC = <any> 'APC',
    ACC = <any> 'ACC',
    SEC = <any> 'SEC',
    SAI = <any> 'SAI',
    CAI = <any> 'CAI'
}
/**
 * 
 * @export
 * @interface Airport
 */
export interface Airport {
    /**
     * 
     * @type {string}
     * @memberof Airport
     */
    icao?: string;
    /**
     * 
     * @type {AirportWeather}
     * @memberof Airport
     */
    weather?: AirportWeather;
    /**
     * 
     * @type {AirportCharts}
     * @memberof Airport
     */
    charts?: AirportCharts;
}
/**
 * 
 * @export
 * @interface AirportCharts
 */
export interface AirportCharts {
    /**
     * 
     * @type {number}
     * @memberof AirportCharts
     */
    items?: number;
    /**
     * Date in format YYYY-MM-DD
     * @type {string}
     * @memberof AirportCharts
     */
    date?: string;
    /**
     * 
     * @type {Array<AirportChartsData>}
     * @memberof AirportCharts
     */
    data?: Array<AirportChartsData>;
    /**
     * 
     * @type {AirportChartsInfo}
     * @memberof AirportCharts
     */
    info?: AirportChartsInfo;
    /**
     * 
     * @type {AirportChartsIvaoData}
     * @memberof AirportCharts
     */
    ivaoData?: AirportChartsIvaoData;
}
/**
 * 
 * @export
 * @interface AirportChartsData
 */
export interface AirportChartsData {
    /**
     * 
     * @type {string}
     * @memberof AirportChartsData
     */
    type?: AirportChartsData.TypeEnum;
    /**
     * Date in format YYYY-MM-DD
     * @type {string}
     * @memberof AirportChartsData
     */
    date?: string;
    /**
     * 
     * @type {string}
     * @memberof AirportChartsData
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AirportChartsData
     */
    link?: string;
}

/**
 * @export
 * @namespace AirportChartsData
 */
export namespace AirportChartsData {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        ADC = <any> 'ADC',
        AOC = <any> 'AOC',
        GMC = <any> 'GMC',
        IAC = <any> 'IAC',
        LC = <any> 'LC',
        PATC = <any> 'PATC',
        PDC = <any> 'PDC',
        SID = <any> 'SID',
        STAR = <any> 'STAR',
        VAC = <any> 'VAC'
    }
}
/**
 * 
 * @export
 * @interface AirportChartsInfo
 */
export interface AirportChartsInfo {
    /**
     * 
     * @type {string}
     * @memberof AirportChartsInfo
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AirportChartsInfo
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof AirportChartsInfo
     */
    state?: string;
    /**
     * 
     * @type {number}
     * @memberof AirportChartsInfo
     */
    lat?: number;
    /**
     * 
     * @type {number}
     * @memberof AirportChartsInfo
     */
    lon?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AirportChartsInfo
     */
    military?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AirportChartsInfo
     */
    civil?: boolean;
    /**
     * 
     * @type {number}
     * @memberof AirportChartsInfo
     */
    fuse?: number;
    /**
     * 
     * @type {number}
     * @memberof AirportChartsInfo
     */
    elevation?: number;
    /**
     * 
     * @type {string}
     * @memberof AirportChartsInfo
     */
    fir?: string;
    /**
     * 
     * @type {Array<AirportChartsInfoRunways>}
     * @memberof AirportChartsInfo
     */
    runways?: Array<AirportChartsInfoRunways>;
    /**
     * 
     * @type {Array<AirportChartsInfoAtcs>}
     * @memberof AirportChartsInfo
     */
    atcs?: Array<AirportChartsInfoAtcs>;
    /**
     * 
     * @type {Array<AirportChartsInfoNavaids>}
     * @memberof AirportChartsInfo
     */
    navaids?: Array<AirportChartsInfoNavaids>;
}
/**
 * 
 * @export
 * @interface AirportChartsInfoAtcs
 */
export interface AirportChartsInfoAtcs {
    /**
     * 
     * @type {string}
     * @memberof AirportChartsInfoAtcs
     */
    connectionCallsign?: string;
    /**
     * 
     * @type {string}
     * @memberof AirportChartsInfoAtcs
     */
    radioCallsignPortuguese?: string;
    /**
     * 
     * @type {string}
     * @memberof AirportChartsInfoAtcs
     */
    radioCallsignEnglish?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof AirportChartsInfoAtcs
     */
    frequencies?: Array<number>;
}
/**
 * 
 * @export
 * @interface AirportChartsInfoNavaids
 */
export interface AirportChartsInfoNavaids {
    /**
     * 
     * @type {string}
     * @memberof AirportChartsInfoNavaids
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof AirportChartsInfoNavaids
     */
    thr?: string;
    /**
     * 
     * @type {string}
     * @memberof AirportChartsInfoNavaids
     */
    icao?: string;
    /**
     * 
     * @type {number}
     * @memberof AirportChartsInfoNavaids
     */
    freq?: number;
}
/**
 * 
 * @export
 * @interface AirportChartsInfoRunways
 */
export interface AirportChartsInfoRunways {
    /**
     * 
     * @type {Array<AirportChartsInfoThresholds>}
     * @memberof AirportChartsInfoRunways
     */
    thresholds?: Array<AirportChartsInfoThresholds>;
    /**
     * 
     * @type {string}
     * @memberof AirportChartsInfoRunways
     */
    surface?: string;
    /**
     * 
     * @type {number}
     * @memberof AirportChartsInfoRunways
     */
    length?: number;
    /**
     * 
     * @type {number}
     * @memberof AirportChartsInfoRunways
     */
    width?: number;
    /**
     * 
     * @type {string}
     * @memberof AirportChartsInfoRunways
     */
    pcn?: string;
}
/**
 * 
 * @export
 * @interface AirportChartsInfoThresholds
 */
export interface AirportChartsInfoThresholds {
    /**
     * 
     * @type {string}
     * @memberof AirportChartsInfoThresholds
     */
    rwy?: string;
    /**
     * 
     * @type {number}
     * @memberof AirportChartsInfoThresholds
     */
    tora?: number;
    /**
     * 
     * @type {number}
     * @memberof AirportChartsInfoThresholds
     */
    toda?: number;
    /**
     * 
     * @type {number}
     * @memberof AirportChartsInfoThresholds
     */
    asda?: number;
    /**
     * 
     * @type {number}
     * @memberof AirportChartsInfoThresholds
     */
    lda?: number;
}
/**
 * 
 * @export
 * @interface AirportChartsIvaoData
 */
export interface AirportChartsIvaoData {
    /**
     * 
     * @type {any}
     * @memberof AirportChartsIvaoData
     */
    rwyConfiguration?: any;
    /**
     * 
     * @type {Array<string>}
     * @memberof AirportChartsIvaoData
     */
    rmk?: Array<string>;
}
/**
 * 
 * @export
 * @interface AirportStatus
 */
export interface AirportStatus {
    /**
     * 
     * @type {string}
     * @memberof AirportStatus
     */
    icao: string;
    /**
     * 
     * @type {string}
     * @memberof AirportStatus
     */
    status: AirportStatus.StatusEnum;
    /**
     * 
     * @type {number}
     * @memberof AirportStatus
     */
    lat: number;
    /**
     * 
     * @type {number}
     * @memberof AirportStatus
     */
    lon: number;
}

/**
 * @export
 * @namespace AirportStatus
 */
export namespace AirportStatus {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        VFR = <any> 'VFR',
        SVFR = <any> 'SVFR',
        IFR = <any> 'IFR'
    }
}
/**
 * 
 * @export
 * @interface AirportWeather
 */
export interface AirportWeather {
    /**
     * 
     * @type {string}
     * @memberof AirportWeather
     */
    metar?: string;
    /**
     * 
     * @type {string}
     * @memberof AirportWeather
     */
    taf?: string;
    /**
     * 
     * @type {string}
     * @memberof AirportWeather
     */
    status?: AirportWeather.StatusEnum;
}

/**
 * @export
 * @namespace AirportWeather
 */
export namespace AirportWeather {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        VFR = <any> 'VFR',
        SVFR = <any> 'SVFR',
        IFR = <any> 'IFR'
    }
}
/**
 * 
 * @export
 * @interface Body
 */
export interface Body {
    /**
     * 
     * @type {string}
     * @memberof Body
     */
    ivaoToken?: string;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {number}
     * @memberof ErrorResponse
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface FlightPlan
 */
export interface FlightPlan {
    /**
     * 
     * @type {string}
     * @memberof FlightPlan
     */
    validSince?: string;
    /**
     * 
     * @type {string}
     * @memberof FlightPlan
     */
    validUntil?: string;
    /**
     * 
     * @type {string}
     * @memberof FlightPlan
     */
    days?: string;
    /**
     * 
     * @type {string}
     * @memberof FlightPlan
     */
    callsign?: string;
    /**
     * 
     * @type {string}
     * @memberof FlightPlan
     */
    acft?: string;
    /**
     * 
     * @type {string}
     * @memberof FlightPlan
     */
    dep?: string;
    /**
     * 
     * @type {string}
     * @memberof FlightPlan
     */
    eobt?: string;
    /**
     * 
     * @type {string}
     * @memberof FlightPlan
     */
    spd?: string;
    /**
     * 
     * @type {number}
     * @memberof FlightPlan
     */
    fl?: number;
    /**
     * 
     * @type {string}
     * @memberof FlightPlan
     */
    route?: string;
    /**
     * 
     * @type {string}
     * @memberof FlightPlan
     */
    dest?: string;
    /**
     * 
     * @type {string}
     * @memberof FlightPlan
     */
    eet?: string;
    /**
     * 
     * @type {string}
     * @memberof FlightPlan
     */
    rmk?: string;
    /**
     * 
     * @type {string}
     * @memberof FlightPlan
     */
    logo?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    token?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse500
 */
export interface InlineResponse500 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse500
     */
    error?: string;
}
/**
 * 
 * @export
 * @interface PaginatedTrainingSessions
 */
export interface PaginatedTrainingSessions {
    /**
     * 
     * @type {number}
     * @memberof PaginatedTrainingSessions
     */
    count?: number;
    /**
     * 
     * @type {Array<TrainingSession>}
     * @memberof PaginatedTrainingSessions
     */
    items?: Array<TrainingSession>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum PilotRating {
    NONE = <any> 'NONE',
    NOTPILOT = <any> 'NOT_PILOT',
    FS1 = <any> 'FS1',
    FS2 = <any> 'FS2',
    FS3 = <any> 'FS3',
    PP = <any> 'PP',
    SPP = <any> 'SPP',
    CP = <any> 'CP',
    ATP = <any> 'ATP',
    SFI = <any> 'SFI',
    CFI = <any> 'CFI'
}
/**
 * 
 * @export
 * @interface PreferentialRouteResponse
 */
export interface PreferentialRouteResponse {
    /**
     * 
     * @type {string}
     * @memberof PreferentialRouteResponse
     */
    icao?: string;
    /**
     * 
     * @type {Array<PreferentialRouteResponseRoutes>}
     * @memberof PreferentialRouteResponse
     */
    routes?: Array<PreferentialRouteResponseRoutes>;
}
/**
 * 
 * @export
 * @interface PreferentialRouteResponseDep
 */
export interface PreferentialRouteResponseDep {
    /**
     * 
     * @type {string}
     * @memberof PreferentialRouteResponseDep
     */
    dep?: string;
    /**
     * 
     * @type {string}
     * @memberof PreferentialRouteResponseDep
     */
    dest?: string;
    /**
     * 
     * @type {string}
     * @memberof PreferentialRouteResponseDep
     */
    route?: string;
    /**
     * 
     * @type {string}
     * @memberof PreferentialRouteResponseDep
     */
    airspace?: string;
    /**
     * 
     * @type {string}
     * @memberof PreferentialRouteResponseDep
     */
    rmk?: string;
}
/**
 * 
 * @export
 * @interface PreferentialRouteResponseRoutes
 */
export interface PreferentialRouteResponseRoutes {
    /**
     * 
     * @type {Array<PreferentialRouteResponseDep>}
     * @memberof PreferentialRouteResponseRoutes
     */
    dep?: Array<PreferentialRouteResponseDep>;
    /**
     * 
     * @type {Array<PreferentialRouteResponseDep>}
     * @memberof PreferentialRouteResponseRoutes
     */
    dest?: Array<PreferentialRouteResponseDep>;
}
/**
 * 
 * @export
 * @interface TrainingSession
 */
export interface TrainingSession {
    /**
     * 
     * @type {number}
     * @memberof TrainingSession
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof TrainingSession
     */
    rating?: TrainingSession.RatingEnum;
    /**
     * 
     * @type {string}
     * @memberof TrainingSession
     */
    type?: TrainingSession.TypeEnum;
    /**
     * 
     * @type {Date}
     * @memberof TrainingSession
     */
    occurrenceDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof TrainingSession
     */
    local?: string;
}

/**
 * @export
 * @namespace TrainingSession
 */
export namespace TrainingSession {
    /**
     * @export
     * @enum {string}
     */
    export enum RatingEnum {
        ADC = <any> 'ADC',
        ACC = <any> 'ACC',
        SEC = <any> 'SEC'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        EXAM = <any> 'EXAM',
        TRAINING = <any> 'TRAINING'
    }
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    lastName?: string;
    /**
     * 
     * @type {ATCRating}
     * @memberof User
     */
    atcRating?: ATCRating;
    /**
     * 
     * @type {PilotRating}
     * @memberof User
     */
    pilotRating?: PilotRating;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    division?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    country?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    staff?: Array<string>;
}
/**
 * AirportsApi - fetch parameter creator
 * @export
 */
export const AirportsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get data from a given airport
         * @param {string} icao 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        airportsIcaoGet(icao: string, options: any = {}): FetchArgs {
            // verify required parameter 'icao' is not null or undefined
            if (icao === null || icao === undefined) {
                throw new RequiredError('icao','Required parameter icao was null or undefined when calling airportsIcaoGet.');
            }
            const localVarPath = `/airports/{icao}`
                .replace(`{${"icao"}}`, encodeURIComponent(String(icao)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("apiKey")
					: configuration.apiKey;
                localVarHeaderParameter["apiKey"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get preferential routes for a given airport
         * @param {string} icao 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        airportsRoutesIcaoGet(icao: string, options: any = {}): FetchArgs {
            // verify required parameter 'icao' is not null or undefined
            if (icao === null || icao === undefined) {
                throw new RequiredError('icao','Required parameter icao was null or undefined when calling airportsRoutesIcaoGet.');
            }
            const localVarPath = `/airports/routes/{icao}`
                .replace(`{${"icao"}}`, encodeURIComponent(String(icao)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("apiKey")
					: configuration.apiKey;
                localVarHeaderParameter["apiKey"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch a list of airports with weather status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        airportsStatusGet(options: any = {}): FetchArgs {
            const localVarPath = `/airports/status`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("apiKey")
					: configuration.apiKey;
                localVarHeaderParameter["apiKey"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AirportsApi - functional programming interface
 * @export
 */
export const AirportsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get data from a given airport
         * @param {string} icao 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        airportsIcaoGet(icao: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Airport> {
            const localVarFetchArgs = AirportsApiFetchParamCreator(configuration).airportsIcaoGet(icao, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get preferential routes for a given airport
         * @param {string} icao 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        airportsRoutesIcaoGet(icao: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PreferentialRouteResponse> {
            const localVarFetchArgs = AirportsApiFetchParamCreator(configuration).airportsRoutesIcaoGet(icao, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Fetch a list of airports with weather status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        airportsStatusGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AirportStatus>> {
            const localVarFetchArgs = AirportsApiFetchParamCreator(configuration).airportsStatusGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AirportsApi - factory interface
 * @export
 */
export const AirportsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get data from a given airport
         * @param {string} icao 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        airportsIcaoGet(icao: string, options?: any) {
            return AirportsApiFp(configuration).airportsIcaoGet(icao, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get preferential routes for a given airport
         * @param {string} icao 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        airportsRoutesIcaoGet(icao: string, options?: any) {
            return AirportsApiFp(configuration).airportsRoutesIcaoGet(icao, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetch a list of airports with weather status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        airportsStatusGet(options?: any) {
            return AirportsApiFp(configuration).airportsStatusGet(options)(fetch, basePath);
        },
    };
};

/**
 * AirportsApi - object-oriented interface
 * @export
 * @class AirportsApi
 * @extends {BaseAPI}
 */
export class AirportsApi extends BaseAPI {
    /**
     * 
     * @summary Get data from a given airport
     * @param {string} icao 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AirportsApi
     */
    public airportsIcaoGet(icao: string, options?: any) {
        return AirportsApiFp(this.configuration).airportsIcaoGet(icao, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get preferential routes for a given airport
     * @param {string} icao 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AirportsApi
     */
    public airportsRoutesIcaoGet(icao: string, options?: any) {
        return AirportsApiFp(this.configuration).airportsRoutesIcaoGet(icao, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Fetch a list of airports with weather status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AirportsApi
     */
    public airportsStatusGet(options?: any) {
        return AirportsApiFp(this.configuration).airportsStatusGet(options)(this.fetch, this.basePath);
    }

}
/**
 * AuthApi - fetch parameter creator
 * @export
 */
export const AuthApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Auth data from a given JWT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authGet(options: any = {}): FetchArgs {
            const localVarPath = `/auth`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authentication required

            // authentication authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("apiKey")
					: configuration.apiKey;
                localVarHeaderParameter["apiKey"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Do Auth base on IVAO Token
         * @param {Body} body IVAO Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authPost(body: Body, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling authPost.');
            }
            const localVarPath = `/auth`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("apiKey")
					: configuration.apiKey;
                localVarHeaderParameter["apiKey"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Body" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Auth data from a given JWT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Do Auth base on IVAO Token
         * @param {Body} body IVAO Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authPost(body: Body, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get Auth data from a given JWT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authGet(options?: any) {
            return AuthApiFp(configuration).authGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Do Auth base on IVAO Token
         * @param {Body} body IVAO Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authPost(body: Body, options?: any) {
            return AuthApiFp(configuration).authPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Get Auth data from a given JWT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authGet(options?: any) {
        return AuthApiFp(this.configuration).authGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Do Auth base on IVAO Token
     * @param {Body} body IVAO Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authPost(body: Body, options?: any) {
        return AuthApiFp(this.configuration).authPost(body, options)(this.fetch, this.basePath);
    }

}
/**
 * RoutesApi - fetch parameter creator
 * @export
 */
export const RoutesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Real Flight plans for a given route
         * @param {string} dep 
         * @param {string} dest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routesDepDestGet(dep: string, dest: string, options: any = {}): FetchArgs {
            // verify required parameter 'dep' is not null or undefined
            if (dep === null || dep === undefined) {
                throw new RequiredError('dep','Required parameter dep was null or undefined when calling routesDepDestGet.');
            }
            // verify required parameter 'dest' is not null or undefined
            if (dest === null || dest === undefined) {
                throw new RequiredError('dest','Required parameter dest was null or undefined when calling routesDepDestGet.');
            }
            const localVarPath = `/routes/{dep}/{dest}`
                .replace(`{${"dep"}}`, encodeURIComponent(String(dep)))
                .replace(`{${"dest"}}`, encodeURIComponent(String(dest)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("apiKey")
					: configuration.apiKey;
                localVarHeaderParameter["apiKey"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoutesApi - functional programming interface
 * @export
 */
export const RoutesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Real Flight plans for a given route
         * @param {string} dep 
         * @param {string} dest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routesDepDestGet(dep: string, dest: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FlightPlan>> {
            const localVarFetchArgs = RoutesApiFetchParamCreator(configuration).routesDepDestGet(dep, dest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RoutesApi - factory interface
 * @export
 */
export const RoutesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get Real Flight plans for a given route
         * @param {string} dep 
         * @param {string} dest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routesDepDestGet(dep: string, dest: string, options?: any) {
            return RoutesApiFp(configuration).routesDepDestGet(dep, dest, options)(fetch, basePath);
        },
    };
};

/**
 * RoutesApi - object-oriented interface
 * @export
 * @class RoutesApi
 * @extends {BaseAPI}
 */
export class RoutesApi extends BaseAPI {
    /**
     * 
     * @summary Get Real Flight plans for a given route
     * @param {string} dep 
     * @param {string} dest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutesApi
     */
    public routesDepDestGet(dep: string, dest: string, options?: any) {
        return RoutesApiFp(this.configuration).routesDepDestGet(dep, dest, options)(this.fetch, this.basePath);
    }

}
/**
 * TrainingScheduleApi - fetch parameter creator
 * @export
 */
export const TrainingScheduleApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a paginated list of Training Sessions
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [occurrenceDateBefore] 
         * @param {string} [occurrenceDateAfter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingScheduleSessionsGet(offset?: number, limit?: number, occurrenceDateBefore?: string, occurrenceDateAfter?: string, options: any = {}): FetchArgs {
            const localVarPath = `/training-schedule/sessions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("apiKey")
					: configuration.apiKey;
                localVarHeaderParameter["apiKey"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (occurrenceDateBefore !== undefined) {
                localVarQueryParameter['occurrenceDateBefore'] = (occurrenceDateBefore as any).toISOString();
            }

            if (occurrenceDateAfter !== undefined) {
                localVarQueryParameter['occurrenceDateAfter'] = (occurrenceDateAfter as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Training Session by ID.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingScheduleSessionsIdGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling trainingScheduleSessionsIdGet.');
            }
            const localVarPath = `/training-schedule/sessions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("apiKey")
					: configuration.apiKey;
                localVarHeaderParameter["apiKey"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrainingScheduleApi - functional programming interface
 * @export
 */
export const TrainingScheduleApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a paginated list of Training Sessions
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [occurrenceDateBefore] 
         * @param {string} [occurrenceDateAfter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingScheduleSessionsGet(offset?: number, limit?: number, occurrenceDateBefore?: string, occurrenceDateAfter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaginatedTrainingSessions> {
            const localVarFetchArgs = TrainingScheduleApiFetchParamCreator(configuration).trainingScheduleSessionsGet(offset, limit, occurrenceDateBefore, occurrenceDateAfter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a Training Session by ID.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingScheduleSessionsIdGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TrainingSession> {
            const localVarFetchArgs = TrainingScheduleApiFetchParamCreator(configuration).trainingScheduleSessionsIdGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TrainingScheduleApi - factory interface
 * @export
 */
export const TrainingScheduleApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Returns a paginated list of Training Sessions
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [occurrenceDateBefore] 
         * @param {string} [occurrenceDateAfter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingScheduleSessionsGet(offset?: number, limit?: number, occurrenceDateBefore?: string, occurrenceDateAfter?: string, options?: any) {
            return TrainingScheduleApiFp(configuration).trainingScheduleSessionsGet(offset, limit, occurrenceDateBefore, occurrenceDateAfter, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a Training Session by ID.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingScheduleSessionsIdGet(id: number, options?: any) {
            return TrainingScheduleApiFp(configuration).trainingScheduleSessionsIdGet(id, options)(fetch, basePath);
        },
    };
};

/**
 * TrainingScheduleApi - object-oriented interface
 * @export
 * @class TrainingScheduleApi
 * @extends {BaseAPI}
 */
export class TrainingScheduleApi extends BaseAPI {
    /**
     * 
     * @summary Returns a paginated list of Training Sessions
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [occurrenceDateBefore] 
     * @param {string} [occurrenceDateAfter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingScheduleApi
     */
    public trainingScheduleSessionsGet(offset?: number, limit?: number, occurrenceDateBefore?: string, occurrenceDateAfter?: string, options?: any) {
        return TrainingScheduleApiFp(this.configuration).trainingScheduleSessionsGet(offset, limit, occurrenceDateBefore, occurrenceDateAfter, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a Training Session by ID.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingScheduleApi
     */
    public trainingScheduleSessionsIdGet(id: number, options?: any) {
        return TrainingScheduleApiFp(this.configuration).trainingScheduleSessionsIdGet(id, options)(this.fetch, this.basePath);
    }

}
